# Chapter 1: Modern Software Is Old

> Every "revolutionary" system eventually converges to the same primitives that COBOL systems used in 1970.

## The Lie

"We're building something new."

No. You're building identity, time, money, and agreements. Again.

## What This Chapter Covers

- The false novelty of modern software
- Why every startup rediscovers ERP
- The 50-year-old patterns hiding in your "disruption"
- Why boring primitives outlast clever abstractions

## Key Points

1. **Identity** - Users, accounts, parties. Same as 1970.
2. **Time** - When things happened. Same as 1970.
3. **Money** - Double-entry ledgers. Same as 1494.
4. **Agreements** - Contracts, terms, obligations. Same as Hammurabi.

## The Uncomfortable Truth

Your React frontend is a thin skin over the same data structures that ran on mainframes. The only difference is you have worse documentation.  the good news is that the AI can write the documentation as it's writing the tests and the code.


When I was a kid my dad brought home punch cards he had programmed as part of his training and his job working in the Air Force programming operating systems on mainframes.
I've grown up with computers I was that generation of having a computer as a kid and in the days of the 1980s.
I had commodore, PC and Apple/Mac over the years.  
Got my first shell account in 1995 at SIUE as a college freshman.  Used the computer for communication primarily but had to learn some shell scripting and uising iunix utilities. learned about pipes learned about operating systems.,
Developed websites in college and post college 
Learned how to program FreeBSD and Linux Servers and the BAMP/LAMP stack where in 2006 I teamed up with a properly trained developer and we begain our career for real building things for clients.
Most were busineses.  Most domains had overlapping primitives. 
We came up with a method using agile/user stories and sprints/developement cycles that we locked down and constgrained each cycle.
to illustrate this we would give our clients big sharpie markers and small notecards and say "put the story on the card ie:  as a user I push the button and this happens."  as a user I log in"  as a user I can see blah blah"  
Then we'd map those to requirements specifications/tasks and technical analysis to design architecture to support those stories.
We'd put their stories up oln the board we had a big metal wall in our conference area and we'd glued pennies nickles dimes and quarters to magnets and we'd have a project backlof of all their ideas with regular magnets. 
We'd set up budget boxes on the boartd and then we'd kind of guide the clients towards building things in a cohesive logical order of dependenciesw and we'd put coin magnests oin their stories/featurews to illusegtrate
the budghet and what they could expect as working software at the end of the cycle.
This worked good for containing scope creep and keeping the project on track while maintaninign flexicbility the onloy ruels were no changes during the current buggdetged sprint. They could add ideas to the board,
they could change their mind, but those changes were not bid or included until the following sprint

There was a log of manual writing of documentation, specs, most of the energy was spent planning and writing documentation and then unit tests.  Testing was difficult, it was very manual at that time wwriting automated browser testing
back then was challenging.


---

*Status: Planned*
